/*
621. 任务调度器

给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。
任务可以以任意顺序执行，并且每个任务都可以在1个单位时间内执行完。在任何一个单位时间，CPU可以完成一个任务，或者处于待命状态。
然而，两个相同种类 的任务之间必须有长度为整数n的冷却时间，因此至少有连续n个单位时间内 CPU在执行不同的任务，或者在待命状态。
你需要计算完成所有任务所需要的 最短时间 。

 

示例 1：
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B
在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 

示例 2：
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0
["A","A","A","B","B","B"]
["A","B","A","B","A","B"]
["B","B","B","A","A","A"]
...
诸如此类

示例 3：
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> (待命) -> (待命) -> A -> (待命) -> (待命) -> A
 
提示：
1 <= task.length <= 104
tasks[i] 是大写英文字母
n 的取值范围为 [0, 100]

解题思路：
1. 一开始无任何解题思路，完全是看 官方的解答才懂的
2. 两种方法，一种是常规的可以很容易就想到的，另一种是需要一定的脑子思考才能想出来的
3. 第一种：哈希表二维数组hash[26][2]，0存放命令次数，1存放当前命令所需时间（初始为1，使用过后为n+1，每次执行缓存时间最小的命令
4. 第二种：就是公式了，如果看这里的解释不能理解的话，那么就去看力扣官方的解答
	4.1 找到执行次数max最多的命令A，那么如果只有A的话，时间消耗为 (max-1)(n+1)+1，因为最后一个不需要冷却时间
	4.2 存在其他命令次数也为max，这种命令个数为maxnum，则时间消耗为 (max-1)(n+1)+maxnum
	4.3 还有一种情况，就是maxnum > n+1，那么时间消耗就是 max(tasksSize, (max-1)(n+1)+maxnum)
*/

//第二种：
int leastInterval(char* tasks, int tasksSize, int n)
{
	int freq[26];
	memset(freq, 0, sizeof(freq));
	for (int i = 0; i < tasksSize; ++i)
		++freq[tasks[i] - 'A'];
	
	// 最多的执行次数
	int maxExec = 0;
	for (int i = 0; i < 26; i++)
		maxExec = fmax(maxExec, freq[i]);
		
	// 具有最多执行次数的任务数量
	int maxCount = 0;
	for (int i = 0; i < 26; i++)
		if (maxExec == freq[i])
	    		maxCount++;
	
	return fmax((maxExec - 1) * (n + 1) + maxCount, tasksSize);
}
