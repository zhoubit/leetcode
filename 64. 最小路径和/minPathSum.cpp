/*
64. 最小路径和

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

示例 1：
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

示例 2：
输入：grid = [[1,2,3],[4,5,6]]
输出：12
 
提示：
m == grid.length
n == grid[i].length
1 <= m, n <= 200
0 <= grid[i][j] <= 100

解题历程：
1. 动态规划，直接遍历一遍就可以了
2. 在原位置上存放最短路径花费 
*/

int minPathSum(int** grid, int gridSize, int* gridColSize)
{
	int i, j, m = gridSize-1, n = gridColSize[gridSize]-1;
	
	for (i = 1; i <= n; i++) //第一横排 
		grid[0][i] += grid[0][i-1];
	
	for (i = 1; i <= m; i++) //第一竖排 
		grid[i][0] += grid[i-1][0];
		
	for (i = 1; i <= m; i++)
		for (j = 1; j <= n; j++)
			grid[i][j] += fmin (grid[i-1][j], grid[i][j-1]);
	
	return grid[m][n];
}
