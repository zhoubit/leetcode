/*
37. 解数独
编写一个程序，通过填充空格来解决数独问题。

一个数独的解法需遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 '.' 表示。

解题历程：
1. 这虽然是个困难题，也没啥用感觉，但我就是喜欢这种题
*/
#include <stdio.h>

void print (char board[9][9])
{
	int i, j;
	
	for (i = 0; i < 9; i++)
	{
		for (j = 0; j < 9; j++)
			printf ("%c ", board[i][j]);
		putchar('\n');
	}
	putchar('\n');
}
//
//void check (int Prob[9][9][9], char board[9][9], int i, int j)
//{
//	int m = i/3*3, n = j/3*3; //九宫格
//	int x, y, tmp, sum = 0;
//	int *prob = Prob[i][j];
//	
//	for (x = 0; x < 9; x++)
//		prob[x] = 0;
//
//	for (x = 0; x < 3; x++) //处理九宫格
//		for (y = 0; y < 3; y++)
//			if (board[m+x][n+y] != '.')
//				prob[board[m+x][n+y]-'1'] = 1;
//
//	for (x = 0; x < 9; x++) //处理竖 
//		if (board[x][j] != '.')
//			prob[board[x][j]-'1'] = 1;
//	
//	for (y = 0; y < 9; y++) //处理横 
//		if (board[i][y] != '.')
//			prob[board[i][y]-'1'] = 1;
//	
//	for (x = 0; x < 9; x++) //统计不能选的数字的个数
//	{
//		if (prob[x] == 1)
//			sum++;
//		else
//			tmp = x+1; //标记可选数字
//	}
//	
//	if (sum == 8) //符合填字条件
//	{
//		board[i][j] = (char)(tmp + '0');print (board);
//		for (x = 0; x < 9; x++)
//			if (board[x][j] == '.')
//				check (Prob, board, x, j); //递归，牵一发而动全身
//		for (y = 0; y < 9; y++)
//			if (board[i][y] == '.')
//				check (Prob, board, i, y); //递归，牵一发而动全身
//				
//		for (x = 0; x < 3; x++) //处理九宫格
//			for (y = 0; y < 3; y++)
//				if (board[m+x][n+y] == '.')
//					check (Prob, board, m+x, n+y); //递归，牵一发而动全身
//	}
//}
//
//int isNoOk (char board[9][9])
//{
//	int i, j;
//	int num = 0;
//	
//	for (i = 0; i < 9; i++)
//		for (j = 0; j < 9; j++)
//			num += board[i][j];
//	return num == 4293 ? 0 : 1;
//}
//
//void solveSudoku(char board[9][9])
//{
//	int i, j, n;
//	int prob[9][9][9] = {0}; //这意味着每个点所能取的所有数值可能性
//	
//	do
//	{
//		for (i = 0; i < 9; i++) //统计可能性
//			for (j = 0; j < 9; j++)
//				if (board[i][j] == '.')
//					check (prob, board, i, j);
//	}while (isNoOk (board));
//}

int check (char board[9][9], int i, int j)
{
	int m = i/3*3, n = j/3*3; //九宫格
	int x, y, num;
//	print(board);
	for (x = 0; x < 9; x++)
	{
		if (x != i && board[x][j] == board[i][j])
		{
			board[i][j] = '.';
			return 0;
		}
		if (x != j && board[i][x] == board[i][j])
		{
			board[i][j] = '.';
			return 0;
		}
	}
	
	for (x = 0; x < 3; x++)
	{
		for (y = 0; y < 3; y++)
		{
			if (x+m != i && y+n != j && board[x+m][y+n] == board[i][j])
			{
				board[i][j] = '.';
				return 0;
			}
		}
	};
	
	if (j < 8)
	{
		for (x = j+1; x < 9; x++)
		{
			if (board[i][x] == '.')
			{
				for (num = 1; num <= 9; num++)
				{
					board[i][x] = num+'0';
					if (check (board, i, x))
						return 1;
				}
				board[i][j] = '.';
				return 0;
			}
		}
	}
	
	for (x = i+1; x < 9; x++)
	{
		for (y = 0; y < 9; y++)
		{
			if (board[x][y] == '.')
			{
				for (num = 1; num <= 9; num++)
				{
					board[x][y] = num+'0';
					if (check (board, x, y))
						return 1;
				}
				board[i][j] = '.';
				return 0;
			}
		}
	}
}

void solveSudoku(char board[9][9])
{
	int i, j, x;
	
	for (i = 0; i < 9; i++) //找第一个没有数字的位置
	{
		for (j = 0; j < 9; j++)
		{
			if (board[i][j] == '.')
			{
				for (x = 1; x <= 9; x++)
				{
					board[i][j] = x+'0';
					if (check (board, i, j))
						return;
				}
			}
		}
	}
}

int main (void)
{
	char test[9][9] = {{'.','.','9','7','4','8','.','.','.'},
			   {'7','.','.','.','.','.','.','.','.'},
			   {'.','2','.','1','.','9','.','.','.'},
			   {'.','.','7','.','.','.','2','4','.'},
			   {'.','6','4','.','1','.','5','9','.'},
			   {'.','9','8','.','.','.','3','.','.'},
			   {'.','.','.','8','.','3','.','2','.'},
			   {'.','.','.','.','.','.','.','.','6'},
			   {'.','.','.','2','7','5','9','.','.'}};
			   
//			   [[".",".","9","7","4","8",".",".","."],
//			   ["7",".",".",".",".",".",".",".","."],
//			   [".","2",".","1",".","9",".",".","."],
//			   [".",".","7",".",".",".","2","4","."],
//			   [".","6","4",".","1",".","5","9","."],
//			   [".","9","8",".",".",".","3",".","."],
//			   [".",".",".","8",".","3",".","2","."],
//			   [".",".",".",".",".",".",".",".","6"],
//			   [".",".",".","2","7","5","9",".","."]]

//	char test[9][9] = {{'5','3','4','.','7','.','.','.','.'},
//			   {'6','.','2','1','9','5','.','.','.'},
//			   {'1','9','8','.','.','.','.','6','.'},
//			   {'8','.','.','.','6','.','.','.','3'},
//			   {'4','.','.','8','.','3','.','.','1'},
//			   {'7','.','.','.','2','.','.','.','6'},
//			   {'.','6','.','.','.','.','2','8','.'},
//			   {'.','.','.','4','1','9','.','.','5'},
//			   {'.','.','.','.','8','.','.','7','9'}};
	
	solveSudoku (test);
	print (test);
	
	return 0;
}
