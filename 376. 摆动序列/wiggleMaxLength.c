/*
376. 摆动序列
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，
第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。

示例 2:
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。

示例 3:
输入: [1,2,3,4,5,6,7,8,9]
输出: 2

进阶:你能否用 O(n) 时间复杂度完成此题?

解题历程：
1. 说实话，一开始看到这题，还感觉挺简单的，但是又看到需要O(n)的时间复杂度，这就需要想想了
2. 也挺简单的，随便想想后就会发现规律
3. 当遍历到i时，如果a[i]>a[i-1]，那么就标记当前是增加的，isIncrease = 1
4. 那么如果后面再遇到增加的情况的话，就选择大的那个，对了一定还要标记好大的位置
5. 其实也不需要那么麻烦，只需要用一个数组存放结果就可以了，然后标记好前一个是增加还是减少的
*/
#include <stdio.h>

int wiggleMaxLength(int* nums, int numsSize)
{
	if (numsSize < 2)
		return numsSize;
	
	int Float, status; //1表示前一个是增加，-1表示前一个是降序
	int i, cur, pre, ret;
	
	ret = 1;
	i = 1;
	while (i < numsSize && nums[i] == nums[0]) //避免连续重复数字
		i++;
	
	if (i < numsSize)
	{
		if (nums[i]-nums[0] > 0)
			Float = 1;
		else
			Float = -1;
		
		ret++;
		pre = nums[i];
	}
	
	for (i++; i < numsSize; i++)
	{
		cur = nums[i];
		status = (cur-pre)*Float;
		if (status > 0)
		{
			pre = cur;
		}
		else if (status < 0)
		{
			pre = cur;
			ret++;
			Float *= -1;
		}
	}
	
	return ret;
}

int main (void)
{
	int a[] = {0,0};
	
	printf ("\nresult = %d\n", wiggleMaxLength(a, sizeof(a)/sizeof(int)));
	
	return 0;
}
